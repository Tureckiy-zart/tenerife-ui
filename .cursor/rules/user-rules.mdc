---
alwaysApply: true
title: User Preferences & Language Rules
version: 1.1
status: Active
owner: Cursor AI
last_updated: 2025-11-25
---

# ğŸ‘¤ User Preferences & Language Rules

This rule file defines user preferences, language processing rules, and communication standards for the UI library project.

---

## ğŸ“‹ Part 1: Language Processing

### Primary Language

**ALWAYS** respond in the user's preferred language:

- **Default**: Russian (if user writes in Russian)
- **Fallback**: English (if user writes in English)
- **Detection**: Based on user's message language

### Language Rules

**ALWAYS** follow these rules:

- Match user's language in responses
- Use technical terms in English (component names, code)
- Provide code examples with English comments
- Translate explanations to user's language

---

## ğŸ’¬ Part 2: Communication Style

### Response Format

**ALWAYS** use clear, structured responses:

- Use markdown formatting
- Include code blocks with syntax highlighting
- Provide step-by-step instructions when needed
- Use emojis sparingly (only when helpful)

### Technical Communication

**ALWAYS** be precise:

- Use exact file paths
- Reference specific line numbers when relevant
- Provide complete code examples
- Explain reasoning behind decisions

---

## ğŸ¯ Part 3: User Intent Recognition

### Task Understanding

**ALWAYS** understand user intent:

- Read full user message before responding
- Identify implicit requirements
- Ask clarifying questions when needed
- Provide multiple solutions when appropriate

### Context Awareness

**ALWAYS** maintain context:

- Remember previous conversation
- Reference relevant files and rules
- Consider project structure
- Follow established patterns

---

## ğŸ“ Part 4: Code Style Preferences

### TypeScript Preferences

**ALWAYS** follow these preferences:

- Use TypeScript strict mode
- Prefer explicit types over `any`
- Use interfaces for object types
- Use type aliases for unions/intersections

### React Component Style

**ALWAYS** follow these patterns:

- Use functional components
- Use hooks for state management
- Prefer named exports
- Include PropTypes or TypeScript types

---

## ğŸ” Part 5: File Reading Preferences

### Reading Strategy

**ALWAYS** read files before editing:

- Read full file for small files (< 500 lines)
- Read relevant sections for large files
- Check file structure before modifications
- Verify file exists before operations

### Context Gathering

**ALWAYS** gather context:

- Read related files when needed
- Check imports and dependencies
- Understand component relationships
- Review test files for expected behavior

---

## ğŸš« Part 6: What NOT to Do

- âŒ **NEVER** ignore user's language preference
- âŒ **NEVER** make assumptions without context
- âŒ **NEVER** skip file reading before editing
- âŒ **NEVER** provide incomplete solutions
- âŒ **NEVER** ignore project conventions
- âŒ **NEVER** modify code without understanding context

---

## âœ… Part 7: What TO Do

- âœ… **ALWAYS** match user's language
- âœ… **ALWAYS** read files before editing
- âœ… **ALWAYS** gather context before changes
- âœ… **ALWAYS** follow project conventions
- âœ… **ALWAYS** provide complete solutions
- âœ… **ALWAYS** explain reasoning

---

## ğŸ“… Part 8: Date and Time Rules

### Date Format

**ALWAYS** use ISO 8601 date format: `YYYY-MM-DD`

- **Format**: `2025-11-25` (not `2025-01-20` or any other date)
- **Timezone**: Use system date/time (current actual date)
- **Examples**: 
  - âœ… `2025-11-25` (correct - current date)
  - âŒ `2025-01-20` (wrong - old date)
  - âŒ `2024-12-19` (wrong - old date)

### Date Usage Rules

**ALWAYS** follow these rules when working with dates:

1. **When updating progress files:**
   - Use **current actual date** from system
   - **NEVER** use hardcoded dates from examples or old code
   - **NEVER** copy dates from other files without checking

2. **When creating reports:**
   - Use **current actual date** for "Date Created" or "Last Updated"
   - Format: `YYYY-MM-DD`

3. **When updating documentation:**
   - Update "Last Updated" field with **current actual date**
   - Format: `YYYY-MM-DD`

4. **When updating task status:**
   - Use **current actual date** for completion dates
   - Format: `YYYY-MM-DD`

### How to Get Current Date

**ALWAYS** get current date using one of these methods:

1. **Terminal command**: `date +"%Y-%m-%d"` (returns current date in YYYY-MM-DD format)
2. **System date**: Use actual current date, not dates from examples
3. **Verify**: If unsure, run `date +"%Y-%m-%d"` to get current date

### Date Examples

**Correct usage:**
```markdown
**Last Updated:** 2025-11-25 (D2 Domain Decoupling completed)
**Date Completed:** 2025-11-25
```

**Incorrect usage:**
```markdown
**Last Updated:** 2025-01-20 (wrong - old date)
**Date Completed:** 2024-12-19 (wrong - old date)
```

### Critical Rule

**NEVER** use dates from:
- âŒ Examples in documentation
- âŒ Old code comments
- âŒ Previous file versions
- âŒ Hardcoded dates in templates

**ALWAYS** use:
- âœ… Current system date
- âœ… Date from `date +"%Y-%m-%d"` command
- âœ… Actual current date when updating files

---

## ğŸ“‹ Communication Checklist

Before responding:

- [ ] Identify user's language
- [ ] Understand user intent
- [ ] Gather necessary context
- [ ] Read relevant files
- [ ] Plan response structure
- [ ] **Get current date using `date +"%Y-%m-%d"` if updating dates**

When providing code:

- [ ] Include complete examples
- [ ] Use proper syntax highlighting
- [ ] Reference file paths
- [ ] Explain changes
- [ ] Consider edge cases
- [ ] **Use current actual date, not hardcoded dates**

---

**Status:** âœ… Active Rule  
**Priority:** HIGH  
**Last Updated:** 2025-11-25  

