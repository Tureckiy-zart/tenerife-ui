---
alwaysApply: true
title: User Preferences & Language Rules
version: 1.0
status: Active
owner: Cursor AI
last_updated: 2024-12-19
---

# ğŸ‘¤ User Preferences & Language Rules

This rule file defines user preferences, language processing rules, and communication standards for the UI library project.

---

## ğŸ“‹ Part 1: Language Processing

### Primary Language

**ALWAYS** respond in the user's preferred language:

- **Default**: Russian (if user writes in Russian)
- **Fallback**: English (if user writes in English)
- **Detection**: Based on user's message language

### Language Rules

**ALWAYS** follow these rules:

- Match user's language in responses
- Use technical terms in English (component names, code)
- Provide code examples with English comments
- Translate explanations to user's language

---

## ğŸ’¬ Part 2: Communication Style

### Response Format

**ALWAYS** use clear, structured responses:

- Use markdown formatting
- Include code blocks with syntax highlighting
- Provide step-by-step instructions when needed
- Use emojis sparingly (only when helpful)

### Technical Communication

**ALWAYS** be precise:

- Use exact file paths
- Reference specific line numbers when relevant
- Provide complete code examples
- Explain reasoning behind decisions

---

## ğŸ¯ Part 3: User Intent Recognition

### Task Understanding

**ALWAYS** understand user intent:

- Read full user message before responding
- Identify implicit requirements
- Ask clarifying questions when needed
- Provide multiple solutions when appropriate

### Context Awareness

**ALWAYS** maintain context:

- Remember previous conversation
- Reference relevant files and rules
- Consider project structure
- Follow established patterns

---

## ğŸ“ Part 4: Code Style Preferences

### TypeScript Preferences

**ALWAYS** follow these preferences:

- Use TypeScript strict mode
- Prefer explicit types over `any`
- Use interfaces for object types
- Use type aliases for unions/intersections

### React Component Style

**ALWAYS** follow these patterns:

- Use functional components
- Use hooks for state management
- Prefer named exports
- Include PropTypes or TypeScript types

---

## ğŸ” Part 5: File Reading Preferences

### Reading Strategy

**ALWAYS** read files before editing:

- Read full file for small files (< 500 lines)
- Read relevant sections for large files
- Check file structure before modifications
- Verify file exists before operations

### Context Gathering

**ALWAYS** gather context:

- Read related files when needed
- Check imports and dependencies
- Understand component relationships
- Review test files for expected behavior

---

## ğŸš« Part 6: What NOT to Do

- âŒ **NEVER** ignore user's language preference
- âŒ **NEVER** make assumptions without context
- âŒ **NEVER** skip file reading before editing
- âŒ **NEVER** provide incomplete solutions
- âŒ **NEVER** ignore project conventions
- âŒ **NEVER** modify code without understanding context

---

## âœ… Part 7: What TO Do

- âœ… **ALWAYS** match user's language
- âœ… **ALWAYS** read files before editing
- âœ… **ALWAYS** gather context before changes
- âœ… **ALWAYS** follow project conventions
- âœ… **ALWAYS** provide complete solutions
- âœ… **ALWAYS** explain reasoning

---

## ğŸ“‹ Communication Checklist

Before responding:

- [ ] Identify user's language
- [ ] Understand user intent
- [ ] Gather necessary context
- [ ] Read relevant files
- [ ] Plan response structure

When providing code:

- [ ] Include complete examples
- [ ] Use proper syntax highlighting
- [ ] Reference file paths
- [ ] Explain changes
- [ ] Consider edge cases

---

**Status:** âœ… Active Rule  
**Priority:** MEDIUM  

